'use strict'
const bbox = require('@turf/bbox').default
const dashify = require('dashify')
const fs = require('fs-extra')

const chart = require('./generate-charts')
const utils = require('./utils')

const config = {
  'chartFunction': {
    'absolute': chart.singleValue,
    'answer': chart.singleValue,
    'average': chart.averageValue,
    'range': chart.singleValue,
    'timeSeries': chart.timeSeries
  }
}

// Generate overall result data
// Returns an array with objects per geography, each with overall and topic
// scores
function generateResultData (geographies, scores, topics) {
  return geographies.map(geo => {
    let geoScores = scores.filter(s => s.geography === geo.name)

    if (geoScores.length) {
      let scoreData = { data: utils.cleanResults(geoScores, 'overall') }
      let topicData = topics.map(t => ({ ...t, data: utils.cleanResults(geoScores, t.id) }))
      return { ...geo, score: scoreData, topics: topicData }
    } else {
      utils.noDataWarning('Overall Scores', geo.name)
      return { ...geo }
    }
  })
}

// Generate detailed result data
// It augments the data generated by generateResultData with the auxiliary
// data needed for the chart
function generateDetailedResultData (resultData, indicators, charts) {
  return resultData.map(geo => {
    // Generate chart data for all types except group
    let chartData = charts
      .filter(c => c.type !== 'group')
      .map(c => config.chartFunction[c.type](geo, indicators, c))

    let groups = charts.filter(c => c.type === 'group')

    return {
      ...geo,
      profile: generateProfileData(geo, indicators),
      charts: groups.length ? chart.groupCharts(chartData, groups) : chartData,
      sectionCopy: generateSectionCopy(geo, indicators)
    }
  })
}

// Generate profile data for a country
function generateProfileData (geo, indicators) {
  let profileData = indicators.filter(i => i.category === 'Country Data' && i.geography === geo.name)

  return profileData.map(ind => {
    // May contain values for multiple years. Get the latest value
    let latestValue = utils.getLatestValue(ind.values)
    return {
      ...latestValue,
      'id': ind.indicator,
      'name': ind.subindicator,
      'unit': ind.units
    }
  })
}

// Generate section copy. The copy of each section on a country profile page is
// stored in the subindicators.csv, under the id 'BNEF Take: [section title]'
// Extract the section copy for all sections from the 'note' property.
function generateSectionCopy (geo, indicators) {
  let countryCopy = indicators
    // The .find checks if value of a particular year is not null
    .filter(i =>
      i.geography === geo.name &&
      i.category === 'BNEF Take' &&
      i.values.find(v => v.year === 2017).value
    )

  if (countryCopy.length) {
    return countryCopy.map(section => {
      let title = section
        .subindicator.split(':')[1]
        .trim()

      return {
        'id': dashify(title),
        'name': title,
        'value': section.values.find(v => v.year === 2017).value
      }
    })
  } else {
    utils.noDataWarning('Section texts', geo.name)
    return null
  }
}

// Generate overview of geographies. Add a bbox
async function generateGeographyData (geographies) {
  const admin = await fs.readJson('./input/lib/ne-110m_bbox.geojson')

  return geographies.map(geo => {
    const ft = admin.features.find(c => c.properties.ISO_A2.toLowerCase() === geo.iso)
    const b = ft ? bbox(ft) : null

    return { ...geo, bbox: b }
  })
}

// Generate an overview of the charts
function generateChartMeta (charts, answers) {
  return charts.map(c => {
    if (c.type === 'answer' || c.type === 'range') {
      c['options'] = answers
        .filter(a => a.indicator === c.indicatorId)
        .map(a => ({
          'id': a.id,
          'label': a.label
        }))
    }
    if (c.type === 'group') {
      c['children'] = c.indicatorId.split('|')
    }
    const { indicatorId, ...d } = c
    return d
  })
}

module.exports = {
  results: generateResultData,
  detailedResults: generateDetailedResultData,
  geographies: generateGeographyData,
  profiles: generateProfileData,
  chartMeta: generateChartMeta
}
